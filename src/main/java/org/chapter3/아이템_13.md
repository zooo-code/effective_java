
## 아이템 13

### Clone 재정의는 주의해서 진행해라

Cloneable 은 복제해도 되는 클래스임을 명시하는 용동의 믹스인 인터페이스지만,

아쉽게도 의도한 목적을 제대로 이루지 못했다.

가장 큰 문제는 clone 메서드가 선언된 곳이 Cloneable 이 아닌 Object 이고, 

그마저도 protected 라는 데 있다.

메서드 하나 없는 Cloneable 인터페이스는 대체 무슨 일을 할까? 

이 인터페이스는 놀랍게도 Object 의 protected 메서드인 clone 의 동작 방식을 결정한다.



자바에서 `clone()` 메서드를 재정의할 때 주의해야 하는 이유는 다음과 같습니다.

1. **얕은 복사와 깊은 복사**: `clone()` 메서드는 기본적으로 얕은 복사를 수행합니다. 
이는 객체가 포함하는 필드들을 복사하지만, 필드가 참조 타입인 경우에는 해당 객체의 참조만 복사합니다. 
이러한 경우, 객체의 내부 상태가 변경되면 복사본과 원본이 동일한 참조를 가리키므로 원치 않는 동작이 발생할 수 있습니다. 이를 방지하기 위해 필요에 따라 깊은 복사를 구현해야 합니다.


2. **Cloneable 인터페이스**: 
- `clone()` 메서드를 사용하기 위해서는 해당 클래스가 `Cloneable`인터페이스를 구현해야 합니다. 
- 그러나 `Cloneable` 인터페이스는 단순히 마킹용 인터페이스이며, 메서드를 강제하지 않습니다. 
- 따라서 `clone()` 메서드를 재정의할 때, 해당 클래스가 `Cloneable` 인터페이스를 구현했는지 확인해야 합니다.


3. **예외 처리**: `clone()` 메서드는 `CloneNotSupportedException`을 던질 수 있습니다. 
하지만 `Cloneable` 인터페이스를 구현한 클래스의 경우에는 이 예외가 발생하지 않는 것이 이상적입니다.
때문에 이러한 예외 처리를 강제받는 것은 번거롭고 오버헤드가 발생할 수 있습니다.


4. **불변 클래스와 가변 클래스의 차이**: 불변 클래스(immutable class)와 가변 클래스(mutable class)는 `clone()` 메서드를 재정의하는 방식이 다를 수 있습니다.
불변 클래스의 경우, 얕은 복사만으로 충분할 수 있지만 가변 클래스의 경우에는 깊은 복사가 필요할 수 있습니다.


5. **버그 발생 가능성**: `clone()` 메서드는 내부 상태를 직접적으로 복사하고 있기 때문에, 
객체의 내부 구조가 변경되면 `clone()` 메서드도 같이 수정해야 합니다. 
그렇지 않으면 예기치 않은 동작이 발생할 수 있습니다.

이러한 이유로 `clone()` 메서드를 재정의할 때는 신중하게 고려해야 합니다. 
대부분의 경우에는 `clone()` 메서드 대신 복사 생성자나 복사 팩토리 메서드를 사용하는 것이 더 안전하고 명확한 방법일 수 있습니다.

---

### 마무리 

`Cloneable` 이 몰고 온 모든 문제를 되짚어 봤을 때, 새로운 인터페이스를 만들 때는 절때 `Cloneable` 을 확장해서는 안되며,

새로운 클래스도 이를 구현해서는 안된다. 

`final` 클래스라면 `Cloneable` 을 구현해도 위험이 크지 않지만, 성능 최적화 관점에서 검도한 후 별 다른 문제가 없을 때만 드물게 허용해야 한다.

기본 원칙은 `복제 기능은 생성자와 팩터리를 이용하는게 최고` 라는 것이다.

단, 배열만 clone 메서드 방식이 가장 깔끔하다. 