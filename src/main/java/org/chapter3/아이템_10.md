## 3장

## 모든 객체의 공통 메서드

이번 장에서는 Object 에 구현된 메서드들에 대한 것을 학습하게 된다.

Object 는 객체를 만들 수 있는 구체 클래스지만 기본적으로 상속해서 사용하도록 설계 되어있다. 

Object 에서 final 이 아닌 메서드(equals, hashCode, toString, clone, finalize)는 

모두 재정의를 염두해 두고 설계된 것이라 재정의 시 지켜야 하는 일반 규약이 명확히 정의되어 있다.


---


## 아이템 10
### equals 는 일반 규약을 지켜 재정의하라.

equals 메서드는 재정의 하기 쉬워 보이지만 곳곳에 함정이 도사리고 있어,

자칫하면 끔찍한 결과를 초래한다. 

이 문제를 회피하는 가장 쉬운 길은 아예 재정의 하지 않는 것이다.

그냥 두면 그 클래스의 인스턴스는 오직 자기 자신과만 같게 된다.

그러니 다음에서 열거한 상황 중 하나에 해댕한다면 재정의 하지 않는 것이 최선이다. 


### equals 를 재정의해야할 때는 언제일까?

객체 식별성 (두 객체가 물리적으로 같은가) 이 아니라 논리적 동치성을 확인해야 하는데, 

상위 클래스의 equals 가 논리적 동치성을 비교하도록 재정의되지 않을 때다.

주로 값 클래스들이 여기 해당한다. 

값 클래스란 Integer 와 String 처럼 값을 표현한 클래스를 말한다. 

두 값 객체를 equals 로 비교하는 프로그래머는 객체가 같은지가 아니라 값이 같은지를 알고 싶어 할 것이다.


---

### equals 메서드를 재정의할 때 일반 규약

`equals()` 메서드를 재정의할 때는 반드시 일반 규약을 따라야 합니다. 이 규약은 Object 클래스의 `equals()` 메서드에 대한 일반적인 규칙을 정의합니다. `equals()` 메서드를 재정의할 때는 다음과 같은 세 가지 규약을 준수해야 합니다.

1. **반사성 (Reflexivity)**: 모든 객체는 자기 자신과 같아야 합니다. 즉, `x.equals(x)`는 true를 반환해야 합니다.

2. **대칭성 (Symmetry)**: 두 객체가 서로 동등하다면(즉, `x.equals(y)`가 true이면), 다른 방향으로 비교해도 결과는 같아야 합니다(즉, `y.equals(x)`도 true여야 합니다).

3. **추이성 (Transitivity)**: 만약 `x.equals(y)`와 `y.equals(z)` 둘 다 true이면, `x.equals(z)`도 true여야 합니다.

또한, `equals()` 메서드를 재정의할 때는 다음을 유의해야 합니다.

- `equals()` 메서드는 `null`을 허용해야 합니다. 즉, `x.equals(null)`은 항상 false를 반환해야 합니다.
- `equals()` 메서드는 `instanceof` 연산자를 사용하여 비교 대상이 같은 클래스의 인스턴스인지 확인해야 합니다. 다른 클래스의 인스턴스와 비교 시에는 항상 false를 반환해야 합니다.
- `equals()` 메서드를 재정의할 때는 반드시 `hashCode()` 메서드도 함께 재정의해야 합니다. 동등한 객체는 동일한 해시 코드를 가져야 합니다.

이러한 규약을 준수하여 `equals()` 메서드를 재정의하면 객체 동등성 비교가 정확하게 이루어질 수 있습니다.

---

### 마무리

꼭 필요한 경우가 아니면 equals 를 재정의하지 말자. 많은 경우 Object 의 equals 가 여러분이 원하는 비교를 정확히 수행해준다.
재정의해야 할 때는 그 클래스의 핵심 필드 모두를 빠짐 없이, 다섯가지 규약을 확실히 지키며 비교해야한다.

