
## 아이템 3

---

### private 생성자나 열거 타입으로 싱글턴임을 보증하라.

- 싱글턴
  - 싱글턴이란, 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말한다. 
  - 싱글턴의 전형적인 예로는 함수와 같은 무상태 객체나 설계상 유일해야 하는 시스템 컴포넌트를 들 수 있다.
  - 하지만, 클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기 어려워질 수 있다.


### 구현
- 싱글턴을 만드는 방식은 보통 둘 중 하나다.
- 두 방식 모두 생성자는 private 으로 감춰두고, 유일한 인스턴스에 접근할 수 있는 수단으로 public static 멤버를 하나 마련해둔다.

첫번째로, public static 멤버가 final 필드인 방식으로 살펴보자.

```java
public class Elvis{
    public static final Elvis INSTANCE = new Elvis();
    
    private Elvis(){
    }
    
    public void leaveTheBuilding(){
    }
}
```

- private 생성자는 public static final 필드인 Elvis.INSTANCE 를 초기화할 때 딱 한 번만 호출된다.
- public 이나 protected 생성자가 없으므로 Elvis 클래스가 초기화 할 때 만들어진 인스턴스가 전체 시스템에서 하나 뿐임을 보장된다.

두번째 방식

```java
public class Elvis{
    public static final Elvis INSTANCE = new Elvis();
    
    private Elvis(){
    }
    public static Elvis getInstance(){
        return INSTANCE;
    }
    public void leaveTheBuilding(){
    }
}
```

하지만 위의 방식도 문제가 있다.

위의 예시에서는 INSTANCE 필드가 static final로 선언되어 있어 직렬화에 사용될 수 있습니다.

하지만 이러한 방식은 역직렬화 과정에서 새로운 인스턴스가 생성되는 것을 방지하지 않습니다. 

즉, 직렬화된 객체를 역직렬화할 때마다 새로운 인스턴스가 생성됩니다.

문제를 해결하기 위해서는 역직렬화 과정에서 새로운 인스턴스가 생성되지 않도록 보장해야 합니다. 이를 위해서는 직렬화된 객체가 역직렬화될 때마다 항상 동일한 인스턴스를 반환하는 방법을 사용해야 합니다.

가장 간단하고 안전한 방법은 열거형(enum)을 사용하는 것입니다. 

열거형(enum)은 직렬화되는 과정에서 내부적으로 적절하게 처리되어 항상 단 하나의 인스턴스만을 유지합니다.

```java
public enum Elvis {
    INSTANCE;

    public void leaveTheBuilding() {
        // 싱글턴 동작
    }
}

```

---
### 마무리

이번 장에는 싱글턴의 올바른 사용법? 에 대하여 학습을 진행했다.