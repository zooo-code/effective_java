## 아이템 8


---

### finalizer 와 cleaner 사용을 피하라

자바는 두가지 객체 소멸자를 제공한다.

그중 finalizer 는 예측할 수 없고, 상황에 따라 위험할 수 있어 일반적으로 불필요하다. 

cleaner 는 finalizer 보다는 덜 위험하지만, 여전히 예측할 수 없고, 느리고 , 일반적을 불필요하다.

finalizer 와 cleaner 는 심각한 성능 문제도 동반한다. 

finalizer 를 사용한 클래스는 finalizer 공격에 노출되어 심각한 보안 문제를 일으킬 수도 있다.


---
자바에서 `finalizer`와 `cleaner`는 객체의 파괴(소멸) 과정에서 사용되는 메커니즘입니다.

1. **Finalizer**:
    - `finalize()` 메서드를 사용하여 객체가 가비지 컬렉션에 의해 파괴되기 직전에 실행됩니다.
    - `finalize()` 메서드는 `Object` 클래스에 정의되어 있으며, 모든 자바 객체가 상속받습니다.
    - 객체가 파괴되기 직전에 사용되어야 하는 자원 해제 등의 작업을 수행할 수 있습니다.
    - 그러나 `finalize()` 메서드의 실행 시점은 JVM에 의해 결정되며, 실행 여부와 타이밍은 보장되지 않습니다. 또한 `finalize()` 메서드를 사용하면 가비지 컬렉션의 성능이 저하될 수 있습니다.

2. **Cleaner**:
    - 자바 9부터 도입된 `Cleaner`는 `finalize()` 메서드의 대안으로 제공됩니다.
    - `Cleaner`는 더 유연하고 안정적으로 객체 파괴 과정을 제어할 수 있도록 합니다.
    - `Cleaner`는 직접적으로 호출되지 않으며, `java.lang.ref.Cleaner` 클래스를 통해 사용됩니다.
    - `Cleaner`는 객체가 소멸될 때 실행할 작업을 등록할 수 있습니다. 이를 통해 사용자가 직접 파괴되는 시점과 동작을 제어할 수 있습니다.
    - `Cleaner`는 `PhantomReference`와 함께 사용됩니다. `PhantomReference`는 가비지 컬렉션 후에 `Cleaner`가 실행되도록 보장합니다.

따라서 자바에서는 주로 `finalize()` 메서드 대신 `Cleaner`를 사용하여 객체의 파괴 과정을 관리하고, 안전하고 효율적으로 자원을 해제합니다.